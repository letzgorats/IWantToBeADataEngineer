# Joining Data with SQL

## USING
- USING 은 JOIN을 할 때, ON 이후에 '테이블.공통된 컬럼'을 써주는 것 대신에, 그냥 USING(공통된 컬럼)으로 써줌으로써 JOIN 을 수행할 수 있게 해준다.

## Multiple JOIN
- 다중 조인은 'AND' 키워드를 써주고 공통된 컬럼을 계속해서 연결해주기만 한다면 3개든 4개든 5개든 다 조인할 수 있다.

## INNER JOIN
- INNER JOIN 은 두 테이블에서 공통된 컬럼 중에 null(missing value) 값이 아닌 것들만 추려서 결과값으로 나온다.


## OUTER JOIN - LEFT JOIN, RIGHT JOIN, FULL JOIN

## LEFT(OUTER) JOIN 과 RIGHT(OUTER) JOIN
- LEFT JOIN 은 왼쪽 테이블을 기준으로 결과가 나온다. 왼쪽 테이블에 있는 컬럼은 다 나오고 공통된 컬럼에서 오른쪽 테이블에 없는 missing value 가 있다면 null 로 채워져서 나온다.(더 흔하게 사용한다.)
- RIGHT JOIN 은 오른쪽 테이블을 기준으로 결과가 나온다. 오른쪽 테이블에 있는 컬럼은 다 나오고 공통된 컬럼에서 왼쪽 테이블에는 없는 missing value 가 있다면 null 로 채워져서 나온다.

## LEFT JOIN 이 RIGHT JOIN 보다 더 흔하게 사용되는 이유
- 아무래도 왼쪽에서 오른쪽으로 테이블을 읽는 것이 더 익숙하기 때문이다. LEFT JOIN 과 RIGHT JOIN 은 자유자재로 변경하면서 똑같은 결과를 만들어 낼 수 있다. 

## FULL(OUTER) JOIN
- FULL JOIN 은 왼쪽 테이블과 오른쪽 테이블의 컬럼 값이 모두 나오는게 특징이다.
- LEFT JOIN 과 OUTER JOIN 과 달리 두 컬럼 모두에 null값이 나올 수 있다는 것이 특징이다.
(LEFT JOIN 에서는 오른쪽테이블에 없는 값이 null 로 채워져서 나왔고, RIGHT JOIN에서는 왼쪽테이블에 없는 값이 null로 채워져서 나왔다. FULL JOIN 에서는 두 테이블에 모두 없는 값이어도, null 값으로 다 채워져서 나온다.)
- (예시) 모든 나라의 대통령과 총리를 다 보고 싶다면 FULL JOIN을 할 수 있다)

![Image](https://github.com/user-attachments/assets/7916d5ca-f4d9-4f5f-ac2a-a1157dccb569)


## CROSS JOIN
- CROSS JOIN 은 두 테이블간의 컬럼의 모든 조합을 결과로 내고 싶을 때 쓴다.(데카르트 곱)
- using이나 on을 통해 공통된 컬럼을 쓸 필요없이 그냥 CROSS JOIN 으로 조인을 수행 할 수 있다. 그래서 결과테이블의 row개수는 두 테이블의 row 개수 간의 곱만큼 나온다


## SELF JOIN
- SELF JOIN 은 한 테이블에서 각기 다른 부분을 서로 비교할때 유용하게 사용된다. 
(예시) 2010년의 인구와 2015년의 인구 변화 등의 비교를 하고 싶을 때
- SELF JOIN 은 INNER JOIN 으로 조인하되, 반드시 alias 를 통해 똑같은 테이블을 구분지어줘야 하고, 공통된 컬럼도 명시를 해줘야 한다.
- WHERE 절에서 중복된 매칭을 피하기 위해 요건에 따라 적절히 <>를 사용하는 문제도 있다.
(예시) 정상회담을 한국이 한국이랑 할 수 없는 것처럼, 이런 예외사항 제거해야 한다


## SET OPERATIONS
- union, intersect, except

## UNION 
- UNION 은 두 테이블의 레코드를 모두 다 결과로 보여준다. 겹치는 row는 한 번만 결과로 내어준다.

## UNION ALL
- UNION ALL 도 두 테이블의 레코드를 모두 다 결과로 보여주긴하지만, union과 다르게 중복된 레코드를 포함한다. 

- 둘 다 select를 해서 테이블을 2개 만든 다음에 UNION이나 UNION ALL 집합 연산을 할 수 있다.
- 원리는 테이블끼리 스택이 쌓이는 것으로 이해하면된다. 때문에 두 테이블 컬럼의 개수와 데이터 타입이 같아야 한다. 이 때, 왼쪽 테이블(집합 연산 전에 오는 테이블)에서 alias를 사용한다면 오른쪽테이블(집합 연산 이후에 오는 테이블)에 alias가 없어도 왼쪽테이블 컬럼이름을 기준으로 최종결과테이블 컬럼이름이 결정된다.(* alias 가 없어도 왼쪽 테이블 기준으로 컬럼이름이 정해진다.)


## INTERSECT
- 두 테이블의 교집합을 결과로 내어준다.
- 이것도 집합연산이기에 두 테이블간의 컬럼 개수와, 데이터 타입이 일치해야 한다.

## INTERSECT vs INNER JOIN
- INNER JOIN 과 INTERSECT 의 차이는 INNER JOIN에서는 중복 레코드를 모두 반환하는 반면, INTERECT 에서는 중복을 제거하고, 일치하는 레코드를 한 번만 반환한다.
- INTERSECT 는 집합연산이기에, 테이블의 컬럼 수와 데이터 타입이 같아야 하고, 공통 값만 반환한다. 하지만, INNER JOIN은 그럴 필요가 없고, 양쪽 테이블의 컬럼을 모두 포함한 결과를 반환한다.
![Image](https://github.com/user-attachments/assets/3f26c18c-a382-465b-8e2d-ae8bca5e8d44)


## EXCEPT
- EXCEPT 는 왼쪽테이블에는 있지만, 오른쪽 테이블에 없는 레코드들을 반환하는 집합 연산이다.(차집합)

## Additive JOINs
- INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN, CROSS JOIN, SELF JOIN 등 6가지 조인은 'additive'방식으로 작동하며, 하나의 테이블에 새로운 열을 추가하는 방식이다.
- 다른 이름의 필드는 원래 이름으로 추가가 되고 동일한 이름의 필드는 중복 열로 추가되며, alias 로 변경이 가능하다.

## SEMI-JOINs
- JOIN 키워드 없이 WHERE 절을 활용하여 조건을 만족하는 레코드를 결과로 반환하는 방식이다.= 조건을 만족하는 데이터만 반환
- 새로운 열이 추가되지 않고, 왼쪽 테이블에 있는 특정 열이 오른쪽 테이블의 특정 열에 존재하는 레코드만 반환한다.

```
SELECT country, continent,president
FROM countries
WHERE country IN(
    SELECT country
    FROM states
    WHERE indep_year < 1800
);
```
- 보통 IN 을 써준다.


## ANTI-JOINs
- JOIN 키워드 없이 WHERE 절을 활용하되, 조건에 맞지 않는 레코드를 결과로 반환하는 방식이다.= 조건에 부합하지 않는 데이터만 반환
- 새로운 열이 추가되지 않고, 왼쪽 테이블에 있는 특정 열이 오른쪽 테이블의 특정 열에 존재하지 않는 레코드만 반환한다.

```
SELECT country, continent,president
 FROM countries
 WHERE continent LIKE '%America'
  ADN country NOT IN(
    SELECT country
    FROM states
    WHERE indep_year < 1800
 );
 ```
- 보통 NOT IN 을 써준다.


## SubQuery
- WHERE 절 안에 또 다른 쿼리를 삽입하여 필터 조건을 활용하는 쿼리(중첩 쿼리를 통해 데이터 필터링)
- SEMI JOINs 과 ANTI JOINs 모두 서브쿼리를 사용하여 동작한다.

## WHERE 절 내의 서브쿼리
- 가장 자주 사용되는 서브쿼리 방법이다.
- WHERE (NOT) IN 절을 사용한다.
- 이 때, 서브쿼리 내의 결과 필드와 메인쿼리에서 WHERE로 필터링을 하는 필드의 데이터 타입이 같아야 한다.
- 서브쿼리의 소스는 같은 테이블에서도 가져올 수 있고, 다른 테이블에서도 가져올 수 있다.



## SELECT 절 내의 서브쿼리
- WEHRE 절 내 서브쿼리에 이어 두 번째로 일반적으로 사용되는 서브쿼리이다.
- 그룹 데이터 집계 시, 원하는 데이터가 서로 다른 테이블에 존재할 경우, GROUP BY 와 JOIN 을 해야 한다. 하지만, SELECT 내의 서브쿼리로 이 작업 없이도 간단하게 추출할 수 있다.

```
SELECT countries.name AS country, COUNT(cities.name) AS cities_num
FROM countries 
LEFT JOIN cities 
ON countries.code = cities.country_code
GROUP BY countries.name
ORDER BY cities_num DESC, country
LIMIT 9
```

에서 SELECT 내의 서브쿼리를 사용하면 아래와 같이 간단하게 쿼리를 짤 수 있다.

```
SELECT countries.name AS country, 
  (SELECT COUNT(cities.name)
   FROM cities
   WHERE cities.country_code = countries.code) AS cities_num
FROM countries
ORDER BY cities_num DESC, country
LIMIT 9;
```


## FROM 절 내의 서브쿼리
- 서브쿼리를 사용하여 임시 테이블처럼 데이터를 다룰 수 있다.
- 콤마를 통해서 FROM 절에 여러 테이블을 포함할 수 있다. 하지만, 이 방식은 id값이 양쪽 테이블에서 여러 번 일치할 경우 중복 레코드를 반환할 수 있기에 DISTINCT 키워드와 함꼐 사용해 중복을 제거할 수 있다.
- 서브쿼리를 FROM 절에 포함해 임시 테이블처럼 사용할 수 있다. alias로 테이블 별칭을 붙여서 사용가능하다.
