## CREATE TABLE

```
CREATE TABLE table_name(
column_name data_type,
    ...
);
```

## ALTER TABLE
```
ALTER TABLE table_name
ADD COLUMN column_name data_type;
```

## RENAME COLUMN
```
ALTER TABLE table_name
RENAME COLUMN old_name TO new_name;
```

## DROP COLUMN
```
ALTER TABLE table_name
DROP COLUMN column_name
```


## INSERT DISTINCT records INTO the new tables

```
INSERT INTO new_table_name
SELECT DISTINCT table_name1,table_name2,...
FROM source_table_name
```

## INSERT INTO
```
INSERT INTO table_name (coulmn_a, coulmnb_b)
VALUES ('value_a','value_b');
```

## DROP TABLE
```
DROP TABLE table_name;
```



## Integrity constraints(무결성 제약 조건)

- 데이터베이스는 데이터를 구조화된 형태로 저장하기 위해 설계된다.
- 데이터를 저장할 때 데이터 타입, 관계, 규칙 등을 사전에 정의하여 데이터 품질을 보장한다.
- 이러한 규칙은 **무결성 제약 조건(integrity constraints)** 이라고 불린다.


## 1. attribute constraints(속성 제약조건)
- 각 열(컬럼)의 **데이터 타입을 지정해서 특정 타입만 지정되도록 제한**
- text 타입과 integer 타입간의 계산은 불가능하니까, 이 때 타입 캐스팅을 사용한다.
- **CAST()함수** 를 사용하면 되는데, 아래와 같이 사용한다.
- (ex) CAST(column_name AS data_type) 형태로 변환 가능
  ```
  -- int타입 column_name1에 varchar타입 column_name2를 곱하는 법
  column_name1 * CAST(column_name2 AS INTEGER) 
  ```

- 데이터 타입은 열 값의 도메인(domain), 즉 혀용되는 값의 형식을 정의한다.
- 이를 통해 데이터 품질을 높이고, 적절한 연산 가능 여부를 제어하며 일관성을 보장한다.


- 문자열
    - text : 길이에 제한이 없는 문자열
    - varchar(n) : 최대 n개의 문자를 허용
    - char(n) : 고정 길이 n개의 문자를 허용
- 불리언 
    - true, false, NULL
- 숫자
    - interger : 특정 범위 정수
    - bigint : 더 큰 범위의 정수
    - numeric(p,s) : 임의의 정밀도를 가지는 숫자
      - (ex) NUMERIC(3,2) 라고 하면 최대 3자리(소수점 이하 2자리) 3.45 이런거
      - p : 전체 자리 수, s : 소수점 이하 자리 수
        
- 날짜 및 시간
    - 날짜와 시간 형식을 다양한 형태로 지원하며, 타임존 포함 가능.

- **데이터 타입은 테이블 생성 시 지정 가능한데, 테이블을 생성하고도 타입 변경이 가능하다.**

    ```
    ALTER TABLE table_name
    ALTER COLUMN column_name
    TYPE 바꿀타입; -- text,varchar(128),char(3),boolean,numeric(3,2),DATE,INTEGER, ...
    ```
    
- **기존 값 변환** 이 필요하다면, **USING** 을 사용해서 기존 데이터를 변환할 수도 있다.
    - (ex) 16자가 넘어가는 데이터가 있을 수 있으니 16자로 끊어서 제한해준다.

    ```
    ALTER TABLE table_name
    ALTER COLUMN column_name
    TYPE varchar(16);
    USING SUBSTRING(column_name 1 FOR 16); -- 기존값에서 첫 16자만 남겨서 새 타입에 적합하게 변환
    ```

- **NOT-NULL** 과 **Unique** 제얀 조건
    - NOT-NULL 제약 조건 : 열(column)에 NULL 값을 보장하지 않는다.(ex) 알루fc로 따지면, 이름
        - NULL 의 의미 
            - NULL 은 **데이터가 알 수 없거나, 존재하지 않거나, 적용되지 않는 경우** 를 나타낸다.
            - (ex) 학생의 사회보장번호(ssn)와 성(last_name)은 NULL 이 될 수 없다.
            - (ex) 집 전화(home_phone)와 사무실 전화(office_phone)은 NULL이 허용된다.(전화가 없을 수 있으므로)
            - 따라서, NULL 끼리의 비교는 은 항상 false 를 반환한다.(NULL != NULL)
            
        <br>
        
        - **NOT-NULL 제약 조건 추가/제거**

            - 테이블 생성시에 NOT-NULL 제약조건 넣을 때

            ```
            CREATE TABLE table_name(column_name data_type NOT NULL);
            ```

            - 기존 테이블에 NOT-NULL 제약조건 추가시에 **ALTER COLUMN** , **SET** 사용

            ```
            ALTER TABLE table_name
            ALTER COLUMN column_name SET NOT NULL;
            ```

            - 기존 테이블에서 NOT-NULL 제약조건 제거시에 **DROP 사용**

            ```
            ALTER TABLE table_name
            ALTER COLUMN column_name DROP NOT NULL;
            ```
                
    <br>     
    
    - Unique 제약 조건 : 열에 중복된 값이 존재할 수 없도록 보장한다. 
        - (ex) 알루fc로 따지면, 등번호 
        - (ex) 대학교의 약칭(short_name)은 중복될 수 없다.(중복되면 데이터의 불필요한 중복 발생)
        - (ex) 대학교의 도시(city)는 중복될 수 있다.(같은 도시에 여러 대학교 존재 가능)
        
        <br>
        
        - **Unique 제약 조건 추가/제거**

            - 테이블 생성시에 Unique 제약조건 넣을 때
        
            ```
            CREATE TABLE table_name(column_name data_type UNIQUE);
            ```

            - 기존 테이블에 Unique 제약조건 추가시에 **ADD CONSTRAINT** , **UNIQUE** 사용

            ```
            ALTER TABLE table_name
            ADD CONSTRAINT some_name UNIQUE(column_name);
            ```

            - 기존 테이블에서 NOT-NULL 제약조건 제거시에 **DROP CONSTRAINT** 사용

            ```
            ALTER TABLE table_name  
            DROP CONSTRAINT some_name;
            ```
            
            

## 2. key constraints(키 제약조건)
- 각 레코드를 고유하게 식별하기 위한 기본키(primary key) 등


- 키 제약 조건은 데이터베이스 시스템에서 attribute 제약 조건 적용한 후, 데이터베이스 모델의 구조를 개선하기 위한 필수 개념이다.
- 데이터베이스 모델의 구조를 개선하기 위해서는 **기본 키(primary key)** 를 추가해야 한다. 기본키는 ERD 다이어그램에서는 밑줄로 표시된다.
- 기본 키는 레코드를 고유하게 식별할 수 있도럭 해준다. 이를 정확히 알려면 먼저 키,슈퍼키의 개념을 알아야한다.

### key 와 superkey의 개념

- superkey는 테이블의 모든 열의 조합으로 고유한 레코드를 식별할 수 있는 키들의 조합이다.

    (ex) 모든 열의 조합이 고유하므로 슈퍼키 -> (license_no, serial_no, model, make + year), (license_no, serial_no), (license_no, model), (serial_no, model, make + year) …등등

- 그 중에서도 최소 슈퍼키(minimal key)는 고유성을 유지하면서 최소한의 키만 남겨놓는 키 조합을 말하는데, 이를 우리는‘key’라고 부른다.

    (ex) (license_no), (serial_no), (model), (make, year)
- 이처럼 **최소 슈퍼키=키** 는 제거가능한 속성이 더 이상 없는 상태이다. 이런 최소 슈퍼키를 또 우리는 **‘후보키’ (candidate key)** 라고 부른다.

즉, 테이블에서 고유성을 보장하는 여러 후보키를 식별하고, 그 중 하나를 선택해 기본키(primary key)로 선택하면 된다.
따라서, **primary key는 not null 임과 동시에 unique 하다고 할 수 있다.**

### surrogate key(대체키)

- primary key가 없을 때, 대체해서 만들 수 있는 키를 말한다. 두 가지 전략이 있다.

1. 아예 새로운 컬럼을 추가하되, 데이터 타입을 serial 로 해서 자동 증가 값으로 설정한 후, 해당 컬럼에 pk 제약조건 거는 법
- 새로운 컬럼을 추가하고 해당 컬럼을 pk 제약조건으로 추가해도 된다.
- (ex) id 라는 필드를 serial 데이터 타입으로 추가한 뒤, pk 제약조건 추가하면, 데이터를 넣을때 자동으로 테이블에 없는 번호가 할당된다.

2. 기존 컬럼의 조합으로 CONCAT()을 톨해 새 컬럼을 만둔 후, 해당 칼럼에 pk 제약조건을 거는 법
- 기존테이블에 있는 컬럼의 조합으로 pk를 만들고 싶으면
  ```
  UPDATE table_bame SET new_col = CONCAT(col1,col2)
  ```
  처럼 CONCAT() 을 이용해 2개 이상의 컬럼 수의 조합으로 새로운 컬럼을 만들고 해당 컬럼에 pk제약조건을 걸면 따로 새로운 필드를 만들지 않고, 기존의 컬럼의 조합으로도 pk를 만들 수 있다. 


## 3. referential integrity constraints(참조 무결성 제약조건)
- 서로 다른 테이블간의 관계를 연결하여 데이터 일관성 유지하는 제약조건이다.
- 이제는 앞서 만든 키 제약조건을 사용할 차례인 것이다.

- 관계 모델링은 ER다이어그램에서 마름모로 나타낸다. 이 때, 카디널리티를 표현하는데, 개체간의 종속성을 숫자로 표시한다.(1...n)

### foreign key(외래키)
- 다른 테이블의 기본 키(pk)를 가리키는 컬럼이다.

- 제약조건
    - 외래키는 참조하는 기본키와 같은 데이터 타입과 도메인을 가져야 한다.
    - 외래 키 값은 기본키에 존재하는 값이어야 한다.(참조 무결성)
    - 외래 키는 중복 및 NULL 값을 허용하므로 반드시 고유하지 않아도 된다.(NULL값은 허용하지만,다른 테이블의 pk에 없는 값이 들어가 있으면 안 된다.)
    - 테이블 생성 또는 수정시에 REFERENCE와 FOREIGN KEY 등의 키워드로 제약조건을 걸어 외래키를 정의할 수 있다.
 
    - 1) 외래키를 포함한 테이블을 생성
            ```
            FOREIGN KEY column_name REFERENCE referenced_table(pk_column);
            ```
        -> 참조를 걸면, 이제는 유효한 값만 테이블에 넣을 수 있다.(즉,fk인 컬럼에 참조된 다른테이블의 pk에 없는 값을 넣으려고 하면 오류가 뜬다는 소리다.)
    - 2) 기존테이블에 외래키를 추가하는 방법
    
            ```
            ALTER TABLE table_name
            ADD CONSTRAINT f_k_name FOREIGN KEY (fk_column) REFERENCES referenced_table(pk_column);
            ```
            
            
### N:M 모델링
- 모델링에서 1:N 관계는 **외래키를 통해 한쪽 테이블에 구현** 하지만, **N:M 관계는 중간테이블을 만들어 구현하며, 두 외래키와 추가속성을 포함한다.** 
- 중간 테이블을 생성할 때는, 각 테이블에서 참조하는 외래키 외에도 추가적인 속성을 추가할 수 있다.
    - (ex.새로생긴 중간테이블(affiliations)에서 professors.id를 참조하는 외래키 professors_id 와 organizations.id를 참조하는 외래키 organization_id 외에도 function 컬럼을 추가해 chairman 같은 데이터를 넣을 수 있게 된다.)
- N:M 이기 때문에 중간 테이블에서는 기본키(pk)를 따로 명시적으로 정하지 않는다.(한 교수가 동일 조직내에서 여러 역할을 가질 수 있기 때문)
- 필요하다면, 컬럼 조합(ex.(professors_id,organizations_id,function) 을 기본 키로 정의해 고유성을 부여해서 pk를 정할 수 있다.
- 과정은 아래와 같다.

    - step1) 중간 테이블 구조 변환
        -  Add a professor_id column
        
            ```
            ALTER TABLE affiliations
            ADD COLUMN professor_id integer REFERENCES professors (id);
            ```

        - Rename the organization column to organization_id
            
            ```
            ALTER TABLE affiliations
            RENAME organization TO organization_id;
            ```

        - Add a foreign key on organization_id

            ```
            ALTER TABLE affiliations
            ADD CONSTRAINT affiliations_organization_fkey FOREIGN KEY (organization_id) REFERENCES organizations (id);
            ```
            
    <br>
        
    - step2) 중간 테이블에서 원하는 컬럼 추가 및 값 채우기
        - (ex.professors 테이블에서 id 가져와서 affiliations 테이블의 professors_id 에 채움)
        - Update professor_id to professors.id where firstname, lastname correspond to rows in professors

            ```
            UPDATE affiliations
            SET professor_id = professors.id
            FROM professors
            WHERE affiliations.firstname = professors.firstname
            AND affiliations.lastname = professors.lastname
            ```
            
    <br>
        
    - step3) 컬럼 삭제
        - (중간 테이블에서 다른 테이블을 참조하기 위해 임시로 사용된 컬럼 제거, 중복 데이터를 제거하여 데이터베이스 중복성 감소를 위함=정규화를 유지하기 위함)
        - DROP THE COLUMN

        ```
        ALTER TABLE affiliations
        DROP COLUMN firstname,
        DROP COLUMN lastname;
        ```

<br>

-  이제 **새로 생긴 중간테이블을 새로운 관계 테이블로 마이그레이션** 을 해야 한다.



## Referential integrity(참조 무결성)
- 쉽게 말해, 테이블A 가 테이블B 의 존재하지 않는 레코들르 참조하면 무결성 위반이 발생한다는 소리다. 
- 즉, 다른 테이블을 참조할 때, 항상 존재하는 레코드를 참조해야 하고 우리는 이걸 외래키(fk)를 통해 구현하며 두 테이블 관계를 실현한다.

- 무결성 위반 사례 
    - 삭제 : 테이블B 의 레코드가 삭제됐는데, 테이블A 에서 해당 레코드를 참조 중인 경우
    - 삽입 : 테이블B에 존재하지 않는 레코드를 테이블A 에서 추가하려고 시도하는 경우
    - 외래키(fk)는 이런 무결성 위반을 방지하기 위해 오류를 발생시킨다.
    
    - 데이터베이스 시스템은 무결성 위반 사례를 막기 위해, 외래키를 정의할 때, **DELETE NO ACTION** 값을 자동으로 디폴트값으로 설정한다.
    ```
    CREATE TABLE table_a(
      id integer PRIMARY KEY,
      column_a varchar(64),
      ...
      b_id integer REFERENCE table_b(id) ON DELETE NO ACTION`
      );
    ```
    
    - 즉, 테이블 A에서 참조된 레코드를 테이블B에서 제거하려고 하면, **자동적으로 오류를 반환** 한다. 
     
    - 이런 디폴트 옵션 말고도, 우리가 옵션 설정을 수동으로 제어할 수 있다.
    
      - CASCADE
            - 참조된 레코드를 삭제하면, 이를 참조하는 모든 레코드도 삭제된다.
        
            
            b_id integer REFERENCE table_b(id) ON DELETE CASCADE
            
            
      - RESTRICT
            - NO ACTION 과 거의 동일하다.(무결성 검사 실행시점이 다르다.NO ACTION은 트랜잭션이 완료될 때 무결성 검사 수행, RESTRICT는 즉시 수행한다.)
            
            
            b_id integer REFERENCE table_b(id) ON DELETE RESTRICT
            
            
      - SET NULL
            - 참조된 레코드를 삭제하면 외래 키 값이 NULL 로 설정된다.

            b_id integer REFERENCE table_b(id) ON DELETE SET NULL
           
           
      - SET DEFAULT
            - 참조된 레코드가 삭제되면 외래 키 값을 사전에 설정한 default값으로 설정한다.
            
            b_id integer REFERENCE table_b(id) ON DELETE SET DEFAULT
            


## 데이터베이스 변환 요약

1) 데이터베이스 변환 
    - 시작점 : 중복이 많은 단순한 테이블(ex.csv, excel 파일)
    - 데이터베이스 스키마로 단계별로 변환
        - 어떻게? **컬럼 데이터 타입 정의 -> pk와 fk 추가 ->테이블 간의 관계 설정** 을 통해 수행했다.
        - 효과? 데이터 일관성을 보장하고 품질을 향상시킬 수 있다. 또, 데이터 추가 및 분석 시 효율적이다.
           ![Image](https://github.com/user-attachments/assets/cc9ce8cd-3e5a-404a-ab99-118301d5ac11)

2) 데이터베이스 생태계
    - DBMS(ex.postgresql)는 SQL을 통한 인터페이스를 제공하고 이를 통해 DB를 관리한다.
    - **데이터베이스 시스템 = DBMS + (하나 이상의 DB)**
         
         
3) 데이터 분석과 데이터베이스의 이점
    - DB는 평면 파일(flat file)보다 분석에 적합하다.(데이터 정규화를 통해 주복을 제거하고, 구조화된 저장 및 쿼리가 가능하기 때문에)
 
