## Matplotlib

- 파이썬에는 많은 패키지가 있지만, 그 중에서 `matplotlib`가 중요하다.
- 이걸 사용하기 위해서는 하위 패키지인 `pyplot` 이 필요하다.
- (ex)
```python
import matplotlib.pyplot as plt
year = [1950,1970,1990,2010]
population = [2.519, 3.692, 5.263, 6.972]
```
- 이 데이터를 "선형 차트"로 표시하려면, `plt.plot()`을 호출하고 두 개의 목록을 인수로 사용하면 된다.
- `첫 번째 인수는 수평축(x)`, `두 번째 인수는 수직축(y)`에 해당한다.
- 그리고, 이 플롯이 실제로 표시되게 하려면, `plt.show()` 함수를 호출하고 기다려야 한다.

## Scatter plot
- 산점도를 그리는 것은 **선이 아니라 점을 그려내는 것**이다. 즉, 단순히 모든 개별 데이터를 점으로 나타내는 것이다.
- `plt.plot()` 대신에, `plt.scatter()`를 호출해야 하고, 표시하려면 마찬가지로 `plt.show()`를 해야한다.
- `plt.xscale('log')`는 x축을 로그변환 하는 방법이다.
(ex)
```python
import matplotlib.pyplot as plt

plt.scatter(x, y, c, s, marker, cmap, alpha)

'''
(x,y) -> 입력값의 타입 : scatter 함수는 x와 y 인자로 배열 또는 값들을 받는다. 일반적으로 NumPy 배열이나 Python 리스트와 같은 순차적인 데이터 타입을 사용한다.

(s,c) -> 크기와 색상 인자
: s와 c 인자는 각각 마커의 크기와 색상을 지정한다. 이들 인자는 스칼라 또는 배열을 허용한다. 스칼라 값을 사용하면 모든 마커가 동일한 크기 또는 색상을 가지게 되고, 배열을 사용하면 각 마커마다 다른 크기 또는 색상을 지정할 수 있다.
: 크기 배열(s)은 음수 값이나 0은 허용되지 않으며, 색상 배열(c)은 0에서 1 사이의 값 또는 0과 1 사이의 RGB 튜플 값을 사용해야 한다.

(marker) -> 마커 모양
: marker 인자는 마커의 모양을 지정한다. 예를 들어, 'o'는 원, '^'는 삼각형, 's'는 사각형 등으로 사용할 수 있다.
: 기본값은 'o'이다.

(cmap) -> 색상 맵
: cmap 인자를 사용하여 색상 맵을 지정할 수 있다.
: 색상 맵은 값의 범위를 색상으로 매핑하는 데 사용된다.
: 예를 들어, 'viridis', 'jet', 'coolwarm' 등의 색상 맵을 사용할 수 있
다.

(alpha) -> 투명도
: alpha 인자를 사용하여 마커의 투명도를 지정할 수 있다.
: 0은 완전히 투명하고 1은 완전히 불투명함을 의미합니다.
'''

```

## Histogram
- 히스토그램을 작성할 때, x축 선을 동일한 단위(=equal chunk)로 나누는데, 이 단위를 `bin` 이라고 한다.(=`width`)
- `bin`의 `width`단위로 나눈 구간에 데이터가 몇개 속해있는지에 따라 높이가 달라지고, 이를 통해 데이터가 어떻게 분포되어있는지 알 수 있다.
- (ex)
```python
import matplotlib.pyplot as plt
values = [0,0,6,1.4,1.6,2.2,2.5,2.6,3.2,3.5,3.9,4.2,6]
plt.hist(values,bins=3)
plt.show()
``` 
- `help(plt.hist)` 를 해보면, hist 인자에 대해서 많이 나오는데,(hist(x,bins=None,range=None,density=False,weights=None,...))
- 그 중에서 가장 중요한 부분인 첫번째 인자 **x는 히스토그램을 작성하려는 값의 목록이어야 한다** 는 것이다.
- 두 번째 인수인 `bins`를 사용하면, python에 데이터를 몇 개의 구간으로 나누어야 하는지 알려줄 수 있다.(bins 개수설정)
- (bins 인수를 지정하지 않으면, 기본적으로 10으로 지정된다.)

## plot 을 customization 하는 법
- 올바른 plot 을 만들고, 메시지를 매우 명확하게 만드는 것이 진짜 도전이다.
- 다양한 `플롯 타입`, `색상`, `모양`, `레이블 축` 등을 변경할 수 있다.

### 축 표시 : xlabel(), ylabel
- 각 축의 이름을 정해준다.
- plt.plot() 후에, plt.show() 전에 레이블을 정해줘야 인식된다.
(ex)
```python
import matplotlib.pyplot as plt
year = [1950,1970,1990,2010]
population = [2.519, 3.692, 5.263, 6.972]
plt.plot(year,population)

plt.xlabel('Year')
plt.ylabel('Population')

plt.show()
```
### 제목 표시 : title()
- 마찬가지로, plt.plot() 후에, plt.show() 전에 Plt.title()을 호출한다.
- plot의 제목을 정해주는 기능을 한다.
```python
import matplotlib.pyplot as plt
year = [1950,1970,1990,2010]
population = [2.519, 3.692, 5.263, 6.972]
plt.plot(year,population)

plt.xlabel('Year')
plt.ylabel('Population')
plt.title('World Population Projections')

plt.show()
```

### yticks() : y축을 정해진 범위에서 시작하고 끝내기(구간 정하기) / xticks() : x축에 ticks 설정하기
- 플롯을 더 정확하게 이해하기 위해서 `y축`을 원하는 구간에서 시작할 수 있다.
- `yticks()` 함수를 사용하면 되는데, `첫 번째 인수`로는 `구간에서 표시될 수`를 리스트로 정해주면 된다.
- `두 번째 인수`로도 리스트를 넣어줄 수 있는데, 이는 yticks()함수에 대한 `틱의 표시 이름이 들어있는 목록`이다.
- 때문에, 첫 번째 인수의 리스트 길이와, 두 번째 인수의 리스트 길이가 같아야 한다.
- `xticks()`도 마찬가지다.

(ex)
```python
import matplotlib.pyplot as plt
year = [1950,1970,1990,2010]
population = [2.519, 3.692, 5.263, 6.972]
plt.plot(year,population)

plt.xlabel('Year')
plt.ylabel('Population')
plt.title('World Population Projections')
plt.yticks([0,2,4,6,8,10])
plt.yticks(['0','2B','4B','6B','8B','10B']) # B는 10억(billion)이라는 의미로 쓴 것!

plt.show()
```

## 데이터 추가하기
- 추가로 데이터를 찾아서 기존 plot에 포함시키고 싶다면, 기존 데이터 리스트에 더해주고 plot을 그리면 된다.
(ex)
```python
import matplotlib.pyplot as plt
year = [1950,1970,1990,2010]
population = [2.519, 3.692, 5.263, 6.972]

year = [1800,1850,1900] + year
population = [1.0,1.262,1.650] + population

plt.plot(year,population)
...
```

### 각 데이터에 text 추가하기
- `plt.text()` 를 통해 각 데이터에 텍스트를 추가할 수 있다.
```python
# Additional customizations
...
plt.text(1550, 71, 'India') # India 점(1550,71) 위에 텍스트가 띄워진다.
plt.text(5700, 80, 'China')
...
```

### plt.grid(True) : 격자 추가하기
- `plt.grid(True)` 를 하면, 격자가 그려진다. 

<br>
<hr>
<br>

## Dictrionaries & Pandas
- 같은 dict 에는 동일한 키가 중복되면 안된다. 만약 그렇게 넣는다면, 마지막에 생성된 키를 기준으로 값이 들어간다.
(ex)
```python
world = {"afghanistan": 30.55, "albania":2.77, "algeria":39.21, "albania":2.81}
world # {afghanistan": 30.55, "albania":2.81, "algeria":39.21 }
```
- 사전의 이러한 고유키는 `불변 객체`(immutable) 이어야 한다.
(ex)
```python
{0:"hello", True:"dear", "two","world"} -> (O)
{["just","to","test"]:"value"} -> (X)
```
- 삭제는 `del` 키워드 사용하면 된다.

https://discord.com/invite/wbHpH2ef
## pandas
- 판다스에서는 같은 테이블 형식의 데이터를 DataFrame 이라는 객체에 저장한다.
- 각 행은 고유하고, 각 열의 값은 서로 다른 유형을 가지고 있을 수 있다.

## 데이터 프레임 만들기 1) 수동으로 만들기
- 사전을 새로 만들어서, 해당 사전에 키,값 쌍을 만드는데, 값을 리스트 형식으로 만든다.
(ex)
```python
dict = {"country" : ["Brazil","Russia","India","China","South Africa"],
        "capital" : ["Brasilia","Moscow","New Delhi","Beijing","Pretoria"],
        "area" : [8.516,17.10,3.286,9.597,1.221],
        "population" : [200.4,143.5,1252,1357,52.98]}
```

- `pandas` 패키지를 pd 로 가져온 후, pd.DataFrame(dict)
(ex)
```python
import pandas as pd
brics = pd.DataFrame(dict)
```
![image](https://github.com/user-attachments/assets/a138ae9f-a0fb-450f-a35f-be56ac26d4bc)


- 수동으로 생성한 DataFrame의 index 속성을 바꾸려면, `.index` 를 활용하면 된다.
(ex)
```python
brics.index = ["BR","RU","IN","CH","SA"]
brics
```
![image](https://github.com/user-attachments/assets/6df8b98e-715d-4ee6-8fe6-b53c39fd60ac)

## 데이터 프레임 만들기 2) CSV 파일에서 그대로 가져오기
- 모든 데이터가 포함된 외부 파일에서 데이터를 가져오는 방법이 있다.
- csv(comma seperated value) 파일을 그대로 가져오면 된다.
- 이 때, pandas 의 `read_csv` 함수를 사용하여 이 데이터를 Python 으로 가져올 수 있다.
- 인수는 csv 파일의 경로를 전달하면 된다.
(ex)
```python
brics = pd.read_csv("path/to/brics.csv")
```

- 그대로 출력하면, 행 레이블은 그 자체로 열로 간주된다. 
![image](https://github.com/user-attachments/assets/cd67dc2a-cd96-4da7-b890-3fa2b71cb0d1)

- 그렇기 때문에, read_csv 함수에 첫번째 열에 행 인덱스가 포함되어 있다고 알려야 한다. `index_col` 인수를 0으로 설정하면 된다.
(ex)
```python
brics = pd.read_csv("path/to/brics.csv",index_col=0)
```
![image](https://github.com/user-attachments/assets/eac89e19-ae1b-43a3-9f25-f4ac30bad3a9)

- read_csv 함수는 이 외에도 데이터 가져오기를 사용자 정의할 수 있는 더 많은 인수를 제공한다.
[read_csv 문서 참조](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html)

## 데이터 프레임에서 인덱싱 접근 1) [] square brackets
- python은 행 레이블과 함께 전체 열을 출력한다.
(ex)
```python
brics["country"]
```
![image](https://github.com/user-attachments/assets/8490911f-7f25-4530-a807-e202010e373e)

- 마지막 줄은 Name:country, dtype:object 라고 되어 있는 것처럼, 일반적인 DataFrame을 다루고 있지는 않다.
- 타입을 찍어보면(type(brics["country"])), `pandas.core.series.Series` 라고 나온다.
![image](https://github.com/user-attachments/assets/493ab6db-d1cc-4298-ae6c-5b1633c13008)

- 단순화된 의미에서 시리즈를 "Dataframe 처럼 레이블을 지정할 수 있는 1차원 배열"로 생각할 수 있다.
- 즉, 여러 개의 Series를 붙여 넣으면, DataFrame을 만들 수 있다.

- 만약, 하나의 열을 선택하지만, DataFrame 내의 데이터를 유지하려는 경우, `이중 대괄호` 가 필요하다.
(ex)
```python
type(brics[["country"]])
```
- 타입을 찍어보면, `pandas.core.frame.DataFrame` 이라고 나온다. DataFrame을 다루고 있는 듯하다.

- 열을 확장하여 호출할 수도 있다.
(ex)
```python
brics[["country","capital"]]
```
![image](https://github.com/user-attachments/assets/a3babff3-2f56-41b6-adeb-b32c0f8801fa)

- 이렇듯, **또 다른 대괄호 세트를 추가하면, 해당 열이 포함된 "하위 DataFrame"이 생성된다.**

## 데이터 프레임에서 인덱싱 접근 2) loc, iloc
- 행을 뽑아낼 때, 슬라이싱도 사용되는데, 이상적으로는 numpy 배열에서처럼 array[rows,columns] 로 하면 좋다고 생각한다.
- 판다스로 비슷한 작업을 하려면, `loc`(label-based), `iloc`(integer position-based) 함수로 도구 상자를 확인해야 한다.

(ex) 러시아의 행을 뽑고 싶다면, loc 뒤에 관심 있는 행의 라벨("RU")을 대괄호로 묶어 넣는다.
```python
brics.loc["RU"]
```
- 다시 말해, 모든 행의 정보를 담고 있는 pandas series를 얻게 되는데, 이는 여러 줄에 걸쳐 불편하게 표시된다.

![image](https://github.com/user-attachments/assets/feaf22d5-5496-48ea-8361-5348d461bf1a)

- 즉, DataFrame 을 얻으려면, `이중 대괄호`를 써서 뽑아야 한다.
(ex)
```python
brics.loc[["RU"]]
```

![image](https://github.com/user-attachments/assets/c72c2c69-b410-4807-a69a-9fd2332b18f3)

- 여러 행을 뽑아내는 것도 마찬가지 원리로 하면 된다.
- 각 레이블의 원하는 열만을 뽑아낼 수도 있다.
- 두 번째 위치에 원하는 열리스트를 콤마로 넣어주면 된다.
(ex)
```python
brics.loc[["RU","IN","CH"],["country","capital"]]
```

![image](https://github.com/user-attachments/assets/50f59caf-004c-4354-aeff-8154e771c371)

- 직접 행 이름, 열 이름을 정해서 넣어도 되지만, 슬라이싱을 활용해서 loc 을 활용해도 된다. 역시 : 를 써도 된다. **`:` 를 쓸 때는 리스트 따로 필요 없다!**
(ex)
```python
brics.loc[:,["country","capital"]]
```

- `iloc`은 `loc`에서 "RU"를 사용한 것 대신에, 인덱스 1을 사용해서 DataFrame 을 얻을 수 있다.
(ex)
```python
brics.loc[["RU"]] # loc
brics.iloc[[1]] # iloc

brics.loc[["RU","IN","CH"] # loc
brics.iloc[[1,2,3]] # iloc

brics.loc[["RU","IN","CH"],["country","capital"]] # loc
brics.iloc[[1,2,3],[0,1] # iloc

brics.loc[:,["country","capital"]] # loc
brics.iloc[:,[0,1]] # iloc
```

- pandas series 로 뽑으려면, loc[] or iloc[]로 하면 되고,
- DataFrame 으로 뽑으려면, loc[[]] or iloc[[]]를 하면 된다.
- 대괄호가 1개냐 2개냐의 차이다.

<br>
<hr>
<br>

##
