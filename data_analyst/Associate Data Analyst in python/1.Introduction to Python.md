## Numpy

- numpy.ndarray 는 list 와 유사하지만, 다른 특징이 있다.
- 바로`전체 배열에 대한 계산`을 수행할 수 있는 것이다.

### list
```python
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4,59.2,63.6,88.4,68.7]

# BMI 계산
weight / height ** 2
```
- `TypeError : unsupported operand type(s) for ** or pow() : 'list' and 'int'` 가 뜬다.

### numpy
```python
import numpy as np
np_height = np.array(height)
np_height
```
- `array([1.73, 1.68, 1.71, 1.89, 1.79])` 

```python
np_weight = np.array(weight)
np_weight
```
- `array([65.4,59.2,63.6,88.4,68.7])` 

```python
bmi = np_weight / np_height ** 2
bmi
```
- `array([21.85171573, 20.97505669, 21.75028214,24.7473475,21.44127836])` 로 각 요소별로 계산이 된다.
- 이처럼, numpy 는 배열을 단일 값처럼 다룬다.

<br>

### numpy 에서 주의할 점

#### 1. numpy 배열은 **하나의 데이터 타입만 담을 수 있다.**

- 아래처럼 Numpy 배열을 만들면, **모든 요소가 `문자열(string)`로 바뀐다.**
```python
[1.0, "is", True]
```

```python
["1.0", "is", "True"]
```

- 아래처럼 numpy 배열을 만들면, **모든 요소가 `정수(int)`로 바뀐다.**
```python
np.array([True, 1, 2]) + np.array([3, 4, False])
# True -> 1 , False -> 0
```

```python
array([4, 5, 2])
```

- **`업캐스팅`** : numpy 배열을 만들 때, **모든 요소를 가능한 한 가장 "일반적인(common)" 타입으로 자동 변환**하려고 하는 것
#### 업캐스팅 우선순위
```cpp
bool < int < float < complex < string
```
- **이 우선순위는 서로 다른 타입이 섞이면, 더 높은 우선순위의 타입으로 변환된다.**

<br>

#### 2. numpy 배열은 python 의 다른 타입(float, str, list) 처럼 `자체적인 자료형` 이다.
- 즉, 고유한 메서드와 동작 방식에 있어서, 기대와 다르게 작동할 수 있다.
```python
python_list = [1,2,3]
numpy_array = np.array([1,2,3])

python_list + python_list   # [1,2,3,1,2,3]
numpy_array + numpy_array   # array([2,4,6])
```
- 똑같은 `+` 연산이지만, 결과가 다르다!

<br>

#### 3. numpy 서브셋 만들기
- numpy 배열도 리스트처럼 인덱싱이 가능하다.

```python
bmi
```
-> `array([21.85171573, 20.97505669, 21.75028214,24.7473475,21.44127836])`

```python
bmi[1]
```
-> `20.975`

- `조건`을 주면 `Boolean` 배열이 생성된다.
```python
bmi > 23
```
-> `array([False,False,False,True,False])`

- 이 `Boolean` 배열을 다시  인덱스로 사용 가능하다.
- 이런 방식은 데이터에서 특정 조건에 맞는 값만 추출할 때 아주 유용하다.
```python
bmi[bmi > 23]
```
-> `array([24.7473475])` 

<hr>

## 2D numpy Arrays 
- 2차원 배열, 3차원 배열, ..., 7차원 배열도 만들 수 있는게 numpy.ndarray 이다.
- `ndarray`는 `n차원 배열(n-dimensional array)` 을 뜻한다.

```python
np_2d = np.array([[180, 70, 165, 65, 175],
                  [75, 55, 60, 65, 80]])
```
- 출력하면 직사각형 구조가 보인다. -> `(2,5)` 
- `.shape` 속성을 이용하면 (행,열) 형태를 확인할 수 있다.
- 여기서 주의할 점은 `메서드는 둥근괄호()` 가 붙지만, `속성은 둥근괄호가 붙지 않는다,` -> `shape` 는 메서드가 아니라 속성!
- numpy 배열이므로 항상 단일 타입만 허용하는 것은 잊지마라! (float 중 하나를 문자열로 바꾸면, 전부 문자열로 업캐스팅 된다는 뜻!)

### 기본 인덱싱
- **리스트처럼 인덱싱이 가능**하다.
```python
np_2d[0][2] # 첫 번째 행의 세 번째 값
```

### 대안 인덱싱(콤마 사용)
- 더 직관적인 방식 : **한쌍의 대괄호 + 콤마**
```python
np_2d[0,2] # 0번째 행, 2번째 열 값
```

### 슬라이싱 사용하기
- 두 번째와 세 번째 사람의 키와 몸무게 선택
```python
np_2d[:,1:3]  # 모든 행, 1~2열
```
-> `2행 2열짜리 배열 반환`

- 두 번째 행(몸무게)만 전체 추출
```python
np_2d[1,:]  # 두 번째 행, 모든 열
```

<hr>

## Numpy 에서 Basic Statistics 정리

| 기능 | 함수 | 설명|
|----|-----|-----------|
|평균|`np.mean()`| 평균값|
|중앙값|`np.median()`| 정렬된 데이터의 중간 값|
|표준편차|`np.std()`| 데이터의 흩어짐 정도|
|상관계수|`np.corrcoef()`| 두 변수 간의 관계|
|합계|`np.sum()`| 모든 값 더하기|
|정렬|`np.sort()`| 값 순서대로 정렬|
|데이터 생성|`np.random.normal()`| 정규분포 기반 무작위 데이터 생성|
|2D 배열 합치기|`np.column_stack()`| 열 기준 배열 합치기|

- Python 에도 `np.sum()`, `np.sort()` 와 같은 기본 함수들이 있지만, numpy 가 훨씬 빠르다.(단일 데이터 타입으로 최적화되어 있기 때문에 속도 ⬆️)

### 데이터 생성 방식
```python
height = np.random.normal(1.75,0.2, 5000)
weight = np.random.normal(70,15,5000)
np_city = np.column_stack((height,weight))
```

### np.random.normal - 정규분포
- `(평균,표준편차, 데이터 개수)` 순으로 파라미터를 준다.
- 다차원의 array 형태로 무작위 샘플을 생성할 수 있다는 것도 random 모듈의 장점이다.
```python
np.random.normal(size=2)
# array([ 0.51421884, 0.22117967])

np.random.normal(size=(2,3))
'''
array([[-1.07004333, -0.18949583, 0.25500144],
        [-0.45802699, 0.43516349, -0.58359505]])
'''

np.random.normal(size=(2,3,4))
'''
array([[[ 0.81684707, 0.67272081, -0.10441114, -0.53128038],
         [ 1.02973269, -0.43813562, -1.11831825, 1.61898166],
         [ 1.54160517, -0.25187914, -0.84243574, 0.18451869]],

        [[ 0.9370822 , 0.73100034, 1.36155613, -0.32623806],
         [ 0.05567601, 0.22239961, -1.443217 , -0.75635231],
         [ 0.81645401, 0.75044476, -0.45594693, 1.18962227]]])
'''
```

### np.random.normal - 균등분포
- `(최소값, 최댓값, 데이터 개수)` 순으로 파라미터를 준다.
 
### `column_stack()` 을 사용해 2D 배열로 합침
- 1차원 백터를 열벡터로 인식하여 세로 방향으로 연결하는 메서드이다.
- 2차원 이상부터는 `np.hstack()`과 같은 동작을 한다.

#### 1차원 배열 예시
```python
v1=np.array([1,2,3])
v2=np.array([4,5,6])
np.column_stack((v1,v2))
'''
array([[1, 4],
       [2, 5],
       [3, 6]])
'''
```
- v1,v2 는 각각 1차원 형태
- `column_stack()`은 이를 (3,1) 형태의 열벡터로 바꾼 뒤, **열 방향으로 붙인다.**
- 결과는 (3,2) 형태의 2차원 배열


#### 2차원 배열 예시 : 2차원 부터는 hstack 함수와 동일한 역할을 한다.
```python
m1=np.array([[1,2],[3,4]])
m2=np.array([[5,6],[7,8]])
np.column_stack((m1,m2))
'''
array([[1, 2, 5, 6],
       [3, 4, 7, 8]])
'''
```
- 이 경우에는 m1,m2가 이미 2차원 배열이기 때문에, `column_stack()`은 **hstack()처럼 그대로 열 방향으로 이어 붙인다.**

## np.column_stack() vs np.hstack() vs np.vstack()
함수명	| 작동 방식 (1D 입력)	| 작동 방식 (2D 입력) |	출력 차원	| 사용 용도 / 특징|
|-----|------------------|------------------|-----------|--------------|
|`np.column_stack()`|1D 배열을 열벡터 (n, 1)로 해석해 열방향 결합|axis=1 기준으로 열방향 결합 |	2D	|여러 1D 벡터를 열 단위 테이블로 만들고 싶을 때|
|`np.hstack()`|	1D 배열을 그냥 붙임 (**평탄화**) → 1D 결과	|axis=1 기준으로 열방향 결합|1D or 2D|**열방향 결합**, 1D 배열끼리 붙이면 1D 결과 주의|
|`np.vstack()`|	1D 배열을 행벡터 (1, n)로 해석해 행방향 결합|axis=0 기준으로 행방향 결합|2D	 |여러 배열을 **행 방향**으로 쌓고 싶을 때|

- 1차원 배열
```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
```
![image](https://github.com/user-attachments/assets/f6b85965-fa82-4337-aa23-408699795bef)

- 2차원 배열
```python
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])
```
![image](https://github.com/user-attachments/assets/69db3595-a3a3-4c00-a23c-285c400e3429)


- Numpy는 이런 데이터 생성 및 시뮬레이션에도 강력



