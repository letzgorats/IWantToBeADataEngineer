## Numpy

- numpy는 list 와 유사하지만, 다른 특징이 있다.
- 바로`전체 배열에 대한 계산`을 수행할 수 있는 것이다.

### list
```python
height = [1.73, 1.68, 1.71, 1.89, 1.79]
weight = [65.4,59.2,63.6,88.4,68.7]

# BMI 계산
weight / height ** 2
```
- `TypeError : unsupported operand type(s) for ** or pow() : 'list' and 'int'` 가 뜬다.

### numpy
```python
import numpy as np
np_height = np.array(height)
np_height
```
- `array([1.73, 1.68, 1.71, 1.89, 1.79])` 

```python
np_weight = np.array(weight)
np_weight
```
- `array([65.4,59.2,63.6,88.4,68.7])` 

```python
bmi = np_weight / np_height ** 2
bmi
```
- `array([21.85171573, 20.97505669, 21.75028214,24.7473475,21.44127836])` 로 각 요소별로 계산이 된다.
- 이처럼, numpy 는 배열을 단일 값처럼 다룬다.

<br>

### numpy 에서 주의할 점

#### 1. numpy 배열은 **하나의 데이터 타입만 담을 수 있다.**

- 아래처럼 Numpy 배열을 만들면, **모든 요소가 `문자열(string)`로 바뀐다.**
```python
[1.0, "is", True]
```

```python
["1.0", "is", "True"]
```

- 아래처럼 numpy 배열을 만들면, **모든 요소가 `정수(int)`로 바뀐다.**
```python
np.array([True, 1, 2]) + np.array([3, 4, False])
# True -> 1 , False -> 0
```

```python
array([4, 5, 2])
```

- **`업캐스팅`** : numpy 배열을 만들 때, **모든 요소를 가능한 한 가장 "일반적인(common)" 타입으로 자동 변환**하려고 하는 것
#### 업캐스팅 우선순위
```cpp
bool < int < float < complex < string
```
- **이 우선순위는 서로 다른 타입이 섞이면, 더 높은 우선순위의 타입으로 변환된다.**

<br>

#### 2. numpy 배열은 python 의 다른 타입(float, str, list) 처럼 `자체적인 자료형` 이다.
- 즉, 고유한 메서드와 동작 방식에 있어서, 기대와 다르게 작동할 수 있다.
```python
python_list = [1,2,3]
numpy_array = np.array([1,2,3])

python_list + python_list   # [1,2,3,1,2,3]
numpy_array + numpy_array   # array([2,4,6])
```
- 똑같은 `+` 연산이지만, 결과가 다르다!

<br>

#### 3. numpy 서브셋 만들기
- numpy 배열도 리스트처럼 인덱싱이 가능하다.

```python
bmi
```
-> `array([21.85171573, 20.97505669, 21.75028214,24.7473475,21.44127836])`

```python
bmi[1]
```
-> `20.975`

- `조건`을 주면 `Boolean` 배열이 생성된다.
```python
bmi > 23
```
-> `array([False,False,False,True,False])`

- 이 `Boolean` 배열을 다시  인덱스로 사용 가능하다.
- 이런 방식은 데이터에서 특정 조건에 맞는 값만 추출할 때 아주 유용하다.
```python
bmi[bmi > 23]
```
-> `array([24.7473475])` 

###

